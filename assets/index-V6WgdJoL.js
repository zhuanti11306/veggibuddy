import{G as t,g as n,m as e,p as i,I as a,f as o,s,c as r,t as l,k as c,l as d,d as u}from"./index-B74hZ3uX.js";import{O as p,Q as h,R as f,S as m,W as v,T as g,U as y,V as w,X as b,Y as S,Z as x,_ as z,$ as _,a0 as E,a1 as T,a2 as L,a3 as A,a4 as P,k as M,a5 as U,G as C,a6 as B,a7 as D,D as O,a8 as j,p as F,a9 as k,aa as V,ab as R,ac as W,q as I,s as G,y as H}from"./index-BruxziNw.js";const q=new g,N=new w;class Y extends p{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new h([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new h([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const n=this.attributes.instanceStart,e=this.attributes.instanceEnd;return void 0!==n&&(n.applyMatrix4(t),e.applyMatrix4(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const e=new f(n,6,1);return this.setAttribute("instanceStart",new m(e,3,0)),this.setAttribute("instanceEnd",new m(e,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const e=new f(n,6,1);return this.setAttribute("instanceColorStart",new m(e,3,0)),this.setAttribute("instanceColorEnd",new m(e,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new v(t.geometry)),this}fromLineSegments(t){const n=t.geometry;return this.setPositions(n.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new g);const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;void 0!==t&&void 0!==n&&(this.boundingBox.setFromBufferAttribute(t),q.setFromBufferAttribute(n),this.boundingBox.union(q))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new y),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==t&&void 0!==n){const e=this.boundingSphere.center;this.boundingBox.getCenter(e);let i=0;for(let a=0,o=t.count;a<o;a++)N.fromBufferAttribute(t,a),i=Math.max(i,e.distanceToSquared(N)),N.fromBufferAttribute(n,a),i=Math.max(i,e.distanceToSquared(N));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)}}toJSON(){}}_.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new z(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},S.line={uniforms:x.merge([_.common,_.fog,_.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat alpha = opacity;\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class K extends b{constructor(t){super({type:"LineMaterial",uniforms:x.clone(S.line.uniforms),vertexShader:S.line.vertexShader,fragmentShader:S.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const X=new T,J=new w,Q=new w,Z=new T,$=new T,tt=new T,nt=new w,et=new A,it=new L,at=new w,ot=new g,st=new y,rt=new T;let lt,ct;function dt(t,n,e){return rt.set(0,0,-n,1).applyMatrix4(t.projectionMatrix),rt.multiplyScalar(1/rt.w),rt.x=ct/e.width,rt.y=ct/e.height,rt.applyMatrix4(t.projectionMatrixInverse),rt.multiplyScalar(1/rt.w),Math.abs(Math.max(rt.x,rt.y))}class ut extends E{constructor(t=new Y,n=new K({color:16777215*Math.random()})){super(t,n),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,n=t.attributes.instanceStart,e=t.attributes.instanceEnd,i=new Float32Array(2*n.count);for(let o=0,s=0,r=n.count;o<r;o++,s+=2)J.fromBufferAttribute(n,o),Q.fromBufferAttribute(e,o),i[s]=0===s?0:i[s-1],i[s+1]=i[s]+J.distanceTo(Q);const a=new f(i,2,1);return t.setAttribute("instanceDistanceStart",new m(a,1,0)),t.setAttribute("instanceDistanceEnd",new m(a,1,1)),this}raycast(t,n){const e=this.material.worldUnits,i=t.camera,a=void 0!==t.params.Line2&&t.params.Line2.threshold||0;lt=t.ray;const o=this.matrixWorld,s=this.geometry,r=this.material;let l,c;if(ct=r.linewidth+a,null===s.boundingSphere&&s.computeBoundingSphere(),st.copy(s.boundingSphere).applyMatrix4(o),e)l=.5*ct;else{l=dt(i,Math.max(i.near,st.distanceToPoint(lt.origin)),r.resolution)}if(st.radius+=l,!1!==lt.intersectsSphere(st)){if(null===s.boundingBox&&s.computeBoundingBox(),ot.copy(s.boundingBox).applyMatrix4(o),e)c=.5*ct;else{c=dt(i,Math.max(i.near,ot.distanceToPoint(lt.origin)),r.resolution)}ot.expandByScalar(c),!1!==lt.intersectsBox(ot)&&(e?function(t,n){const e=t.matrixWorld,i=t.geometry,a=i.attributes.instanceStart,o=i.attributes.instanceEnd;for(let s=0,r=Math.min(i.instanceCount,a.count);s<r;s++){it.start.fromBufferAttribute(a,s),it.end.fromBufferAttribute(o,s),it.applyMatrix4(e);const i=new w,r=new w;lt.distanceSqToSegment(it.start,it.end,r,i),r.distanceTo(i)<.5*ct&&n.push({point:r,pointOnLine:i,distance:lt.origin.distanceTo(r),object:t,face:null,faceIndex:s,uv:null,uv1:null})}}(this,n):function(t,n,e){const i=n.projectionMatrix,a=t.material.resolution,o=t.matrixWorld,s=t.geometry,r=s.attributes.instanceStart,l=s.attributes.instanceEnd,c=Math.min(s.instanceCount,r.count),d=-n.near;lt.at(1,tt),tt.w=1,tt.applyMatrix4(n.matrixWorldInverse),tt.applyMatrix4(i),tt.multiplyScalar(1/tt.w),tt.x*=a.x/2,tt.y*=a.y/2,tt.z=0,nt.copy(tt),et.multiplyMatrices(n.matrixWorldInverse,o);for(let u=0,p=c;u<p;u++){if(Z.fromBufferAttribute(r,u),$.fromBufferAttribute(l,u),Z.w=1,$.w=1,Z.applyMatrix4(et),$.applyMatrix4(et),Z.z>d&&$.z>d)continue;if(Z.z>d){const t=Z.z-$.z,n=(Z.z-d)/t;Z.lerp($,n)}else if($.z>d){const t=$.z-Z.z,n=($.z-d)/t;$.lerp(Z,n)}Z.applyMatrix4(i),$.applyMatrix4(i),Z.multiplyScalar(1/Z.w),$.multiplyScalar(1/$.w),Z.x*=a.x/2,Z.y*=a.y/2,$.x*=a.x/2,$.y*=a.y/2,it.start.copy(Z),it.start.z=0,it.end.copy($),it.end.z=0;const n=it.closestPointToPointParameter(nt,!0);it.at(n,at);const s=P.lerp(Z.z,$.z,n),c=s>=-1&&s<=1,p=nt.distanceTo(at)<.5*ct;if(c&&p){it.start.fromBufferAttribute(r,u),it.end.fromBufferAttribute(l,u),it.start.applyMatrix4(o),it.end.applyMatrix4(o);const n=new w,i=new w;lt.distanceSqToSegment(it.start,it.end,i,n),e.push({point:i,pointOnLine:n,distance:lt.origin.distanceTo(i),object:t,face:null,faceIndex:u,uv:null,uv1:null})}}}(this,i,n))}}onBeforeRender(t){const n=this.material.uniforms;n&&n.resolution&&(t.getViewport(X),this.material.uniforms.resolution.value.set(X.z,X.w))}}class pt extends Y{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const n=t.length-3,e=new Float32Array(2*n);for(let i=0;i<n;i+=3)e[2*i]=t[i],e[2*i+1]=t[i+1],e[2*i+2]=t[i+2],e[2*i+3]=t[i+3],e[2*i+4]=t[i+4],e[2*i+5]=t[i+5];return super.setPositions(e),this}setColors(t){const n=t.length-3,e=new Float32Array(2*n);for(let i=0;i<n;i+=3)e[2*i]=t[i],e[2*i+1]=t[i+1],e[2*i+2]=t[i+2],e[2*i+3]=t[i+3],e[2*i+4]=t[i+4],e[2*i+5]=t[i+5];return super.setColors(e),this}setFromPoints(t){const n=t.length-1,e=new Float32Array(6*n);for(let i=0;i<n;i++)e[6*i]=t[i].x,e[6*i+1]=t[i].y,e[6*i+2]=t[i].z||0,e[6*i+3]=t[i+1].x,e[6*i+4]=t[i+1].y,e[6*i+5]=t[i+1].z||0;return super.setPositions(e),this}fromLine(t){const n=t.geometry;return this.setPositions(n.attributes.position.array),this}}class ht extends ut{constructor(t=new pt,n=new K({color:16777215*Math.random()})){super(t,n),this.isLine2=!0,this.type="Line2"}}function ft(t,n,e){const i=e.clone().multiplyScalar(.5),a=n.clone(),o=t.clone();return{getTangent:t=>i.clone().multiplyScalar(2*t).add(a),getPosition(t){const n=i.clone().multiplyScalar(t*t),e=a.clone().multiplyScalar(t);return n.add(e).add(o)},step(t,n,e){const i=[];for(let a=0;a<=e;a++){const o=t+(n-t)*a/e;i.push(this.getPosition(o))}return i}}}const mt=new w(0,-9.81,0);let vt=null;const{promise:gt,resolve:yt}=Promise.withResolvers(),wt=D.throwingGame.models.field,bt=e(()=>F.isLegal?{id:F.type,assets:j[F.type]}:null),{promise:St,resolve:xt}=Promise.withResolvers();let zt=null;const _t={_state:0,start:{x:0,y:0},current:{x:0,y:0},get state(){return this._state},set state(t){if(this._state=t,vt)switch(t){case 0:case 1:vt.controls.enabled=!0;break;case 2:vt.controls.enabled=!1}}};const Et=function(t){const n=t.querySelector("canvas");if(!n)throw new Error("Canvas element not found in container.");const e=vt=B(t,n,k.throwingBallGame);yt(e);const i=function(t){const n=new E(new V(.025,16,16),new R({color:16733525,roughness:.5,metalness:0}));n.castShadow=!0,n.receiveShadow=!0,t.add(n),n.position.set(0,.025,.25);const e=new ht(new pt,new K({linewidth:3,color:16711680,dashed:!0,dashSize:.03125,gapSize:.0078125}));return e.visible=!1,t.add(e),{ball:n,parabolaLine:e}}(e.scene);let a=null;return Promise.all([wt.whenLoaded,St]).then(([n,o])=>{e.info.gyroTuner.enable();const s=o.model.object,{animation:r,animationState:l,reset:c}=function(t,n){const e={hadFirstThrow:!1,chasingBallState:0,currentChasingTarget:null,allowKickBall:!1,ballStartMoving:null,ballThrowingTime:null,predictParabolaCurve:null,throwParabolaCurve:null,moving:null};function i(i,a){if(e.throwParabolaCurve){null!==e.ballStartMoving&&null!==e.ballThrowingTime||(e.ballThrowingTime=e.ballStartMoving=a);const i=a-e.ballThrowingTime,o=e.throwParabolaCurve.getPosition(i/1e3);if(n.ball.position.copy(o),a-e.ballStartMoving>250&&t.position.distanceTo(n.ball.position)>.1&&0===e.chasingBallState&&(e.chasingBallState=1),o.y<.025){n.ball.position.y=.025;const t=(new w).copy(n.ball.position),i=(new w).copy(e.throwParabolaCurve.getTangent(0));i.multiply(new w(.75,.5,.75)),i.x>.0078125||i.x<-.0078125||i.z>.0078125||i.z<-.0078125?(e.ballThrowingTime=a,e.throwParabolaCurve=ft(t,i,mt)):0===_t.state&&(e.ballStartMoving=null,e.throwParabolaCurve=null)}}if(e.hadFirstThrow){const i=(new w).copy(n.ball.position).setY(t.position.y);t.lookAt(i);const o=n.ball.position.distanceTo(t.position),s=(new w).copy(i).setY(0).length();if((!e.throwParabolaCurve||e.chasingBallState)&&!e.moving){const i=(new w).copy(n.ball.position).setY(t.position.y);let a=null;switch(e.chasingBallState){case 0:if(o>.1)e.chasingBallState=1;else{Math.random()<.0025&&(e.allowKickBall=!0)}break;case 1:if(!e.currentChasingTarget){const n=new w(0,1,0),a=(new w).copy(i).setY(0),o=(new w).crossVectors(n,a).normalize().multiplyScalar(.085),s=(new w).copy(i).sub(o),r=(new w).copy(i).add(o),l=(new w).copy(i).addScaledVector(a.normalize(),.085),c=s.distanceTo(t.position),d=r.distanceTo(t.position),u=l.distanceTo(t.position);switch(Math.min(c,d,u)){case u:e.currentChasingTarget=l;break;case c:e.currentChasingTarget=s;break;case d:e.currentChasingTarget=r}}(new w).subVectors(e.currentChasingTarget,t.position).length()<.01?(e.currentChasingTarget=null,e.chasingBallState=2):a=e.currentChasingTarget;break;case 2:if(o>.1)e.chasingBallState=1;else{const n=(new w).copy(i).setY(0).normalize().multiplyScalar(.085),o=(new w).copy(i).add(n);o.distanceTo(t.position)>.01&&(a=o),e.chasingBallState=0}}if(a){a.setY(0);const n=(new w).subVectors(a,t.position),i=n.length();if(n.normalize().multiplyScalar(i/Math.ceil(i/.25)),e.moving=function(t,n,e,i=1.75){const a=function(t,n,e,i,a="low"){const o=e.clone().multiplyScalar(.5),s=n.clone().sub(t),r=s.lengthSq(),l=o.lengthSq(),c=i*i+s.dot(e),d=c*c-4*l*r;if(d<0)return null;const u=(c+("high"===a?1:-1)*Math.sqrt(d))/(2*l);if(u<0)return null;const p=Math.sqrt(u);return{duration:p,...ft(t,s.clone().multiplyScalar(1/p).sub(o.clone().multiplyScalar(p)),e)}}(n,e,mt,i,"high");if(!a)return null;const{promise:o,resolve:s}=Promise.withResolvers(),r=250,l=1e3*a.duration,c=200,d=a.getTangent(0).length(),u=a.getTangent(a.duration),p=u.length()/d,h=t.scale.y;let f=!1;const m=.25;return{animation(n,e){let i=1;if(e<r){const t=e/r,n=t*t;i=1+.5*m*(3*n-2*t+Math.sqrt(8)*(n-t))}else if(e<r+l){const n=(e-r)/1e3,o=a.getTangent(n).length();i=1+m*(1-o/d),t.position.copy(a.getPosition(n))}else if(e<r+l+c){const n=(e-r-l)/c,o=n*n;i=1+m*p*(2*o-3*n+1+Math.sqrt(3)*(o-n)),f||(t.position.copy(a.getPosition(a.duration)),t.position.y=0,f=!0)}else s(),t.scale.y=h,t.scale.x=t.scale.z=h;t.scale.y=h*i,t.scale.x=t.scale.z=h/Math.sqrt(i)},promise:o}}(t,t.position.clone(),t.position.clone().add(n)),e.moving){const t=e.moving.animation;O(t),e.moving.promise.then(()=>{e.moving=null,C(t)})}}}if(e.allowKickBall&&!e.predictParabolaCurve&&o<.1&&s>.5){const i=(new w).subVectors(n.ball.position,t.position).setY(0).normalize();i.setY(.25),i.applyAxisAngle(new w(0,1,0),(Math.random()-.5)*Math.PI/8);const o=ft(n.ball.position.clone(),i,mt);e.throwParabolaCurve=o,e.ballThrowingTime=a,e.allowKickBall=!1}}}function a(){e.hadFirstThrow=!1,e.chasingBallState=0,e.currentChasingTarget=null,e.allowKickBall=!1,e.ballStartMoving=null,e.ballThrowingTime=null,e.predictParabolaCurve=null,e.throwParabolaCurve=null,e.moving?.animation&&C(e.moving.animation),e.moving=null}return{animation:i,animationState:e,reset:a}}(s,i);function d(t){!function(t,n,e){W.setFromCamera(t,n),W.intersectObject(e).length?(_t.state=2,_t.start.x=_t.current.x=t.x,_t.start.y=_t.current.y=t.y):_t.state=0}(new z(t.offsetX,t.offsetY).applyMatrix3(e.pointerNormalize),e.camera,i.ball)}function u(t){switch(_t.state){case 0:break;case 2:{const{offsetX:n,offsetY:a}=t;_t.current.x=n,_t.current.y=a;const o=new z(n,a).applyMatrix3(e.pointerNormalize),s=new w,r=i.ball.position.distanceTo(e.camera.position);W.setFromCamera(o,e.camera),W.ray.at(r,s);const c=mt,d=i.ball.position.clone(),u=(new w).subVectors(d,s).multiply(new w(8,16,8)).multiplyScalar(1/r),p=new w(u.x,0,u.z),h=2;if(p.length()>h&&(p.setLength(h),u.x=p.x,u.z=p.z),u.y>2&&(u.y=2),u.length()>=.0625){l.predictParabolaCurve=ft(d,u,c);const t=l.predictParabolaCurve.step(0,.375,20);i.parabolaLine.geometry.setFromPoints(t),i.parabolaLine.computeLineDistances(),i.parabolaLine.geometry.attributes.position.needsUpdate=!0,i.parabolaLine.visible=!0}break}}}function p(t){switch(_t.state){case 0:break;case 2:i.parabolaLine.visible=!1,l.throwParabolaCurve=l.predictParabolaCurve,l.predictParabolaCurve=null,l.hadFirstThrow=!0}_t.state=0}O(r),t.addEventListener("pointerdown",d),t.addEventListener("pointermove",u),t.addEventListener("pointerup",p),a=()=>{C(r),l.moving?.animation&&C(l.moving.animation),t.removeEventListener("pointerdown",d),t.removeEventListener("pointermove",u),t.removeEventListener("pointerup",p)},Tt=()=>{c(),s.position.set(0,0,.5),s.lookAt(new w(0,0,0)),i.ball.position.set(0,.025,.25),i.parabolaLine.visible=!1,e.camera.position.set(0,.0859375,-1/4096),e.camera.lookAt(new w(0,.0859375,1))}}),{destroy(){e.dispose(),a?.()}}};let Tt=null;function Lt(){Tt?.()}var At=()=>history.back(),Pt=o('<div class="container svelte-1h15yrr"><canvas class="svelte-1h15yrr"></canvas> <button type="button" class="button left svelte-1h15yrr"><img alt="返回" draggable="false" class="svelte-1h15yrr"/> <span class="label svelte-1h15yrr">返回</span></button> <button type="button" class="button center-left svelte-1h15yrr"><img alt="前進" draggable="false" class="svelte-1h15yrr"/> <span class="label svelte-1h15yrr">前進</span></button> <button type="button" class="button center-right svelte-1h15yrr"><img alt="後退" draggable="false" class="svelte-1h15yrr"/> <span class="label svelte-1h15yrr">後退</span></button> <button type="button" class="button right svelte-1h15yrr"><img alt="重置" draggable="false" class="svelte-1h15yrr"/> <span class="label svelte-1h15yrr">重置</span></button></div>');function Mt(e,o){i(o,!1),t(()=>{if(!n(bt))return void M();const t=n(bt).id;Promise.all([U(t),gt]).then(([t,{scene:n}])=>{t.model.object&&(n.add(t.model.object),t.model.object.position.set(0,0,.5),t.model.object.lookAt(new w(0,0,0))),zt?.model.object&&n.remove(zt.model.object),xt(zt=t)})}),a();var u=Pt(),p=s(r(u),2);p.__click=[At];var h=r(p),f=s(p,2),m=r(f);I(f,t=>function(t){function n(t){if(!vt)return;const n=vt.camera,e=vt.controls,i=n.getWorldDirection(new w).setY(0).normalize();n.position.addScaledVector(i,.3*t/1e3),e.target.addScaledVector(i,.3*t/1e3)}function e(){O(n)}function i(){C(n)}return t.addEventListener("pointerdown",e),t.addEventListener("pointerup",i),{destroy(){t.removeEventListener("pointerdown",e),t.removeEventListener("pointerup",i),C(n)}}}?.(t));var v=s(f,2),g=r(v);I(v,t=>function(t){function n(t){if(!vt)return;const n=vt.camera,e=vt.controls,i=n.getWorldDirection(new w).setY(0).normalize();n.position.addScaledVector(i,-.3*t/1e3),e.target.addScaledVector(i,-.3*t/1e3)}function e(){O(n)}function i(){C(n)}return t.addEventListener("pointerdown",e),t.addEventListener("pointerup",i),{destroy(){t.removeEventListener("pointerdown",e),t.removeEventListener("pointerup",i),C(n)}}}?.(t));var y=s(v,2);y.__click=function(...t){Lt?.apply(this,t)};var b=r(y);I(u,t=>Et?.(t)),l(()=>{G(h,"src",H.chat.src),G(m,"src",H.chat.src),G(g,"src",H.chat.src),G(b,"src",H.chat.src)}),c(e,u),d()}u(["click"]);export{Mt as default};
